---
title: 零散的随笔总结
key: 20180808
tags:
- SQL
- B+ Tree
- 设计模式
- 堆排序
- Top-K
- 多线程 
---

## 一、SQL索引 ##

&nbsp;&nbsp;&nbsp;&nbsp;数据库索引是由B+ Tree这种平衡多路查找树实现的，他会在数据库中维护由索引字段的值构成的B+ Tree结构，因此在插入及删除时由于要维护树的结构，会导致插入删除的效率降低，但是查询效率很高。每次给字段新建一个索引时，字段中的数据就会被复制一份出来。用于生成索引。因此，给表增加索引，会增加表的体积，占用磁盘空间。

<!--more-->

## 二、设计模式 ##

- **策略模式**： 使用组合而非继承的方式，可以动态修改类的行为，联想游戏角色及游戏武器
- **观察者模式**： 观察者模式有两种实现形式，一是push，发布者将所有信息一次发送给所有订阅者，由订阅者处理信息。二是pull，通知订阅者自行来拉取所需要的信息。联想**天气显示应用程序**
- **工厂模式**：**简单工厂**：传入类型，在简单工厂类中做if-else或者switch判断需要生厂的继承自抽象产品的具体产品。 **工厂方法**：同时定义抽象工厂及抽象产品类，去除if-else等分支判断，若需要新增方法则分别添加该产品的具体工厂类及产品类。  **反射实现工厂方法**： 利用反射技术，可以将生产模式以配置文件或者字符串的形式传入，来生成指定的产品（例如Python中的eval及exec方法）

## 三、堆排序 ##
- 堆排序的实现
- heapify方法构建堆
- Top K问题

## 四、进程及线程通信。同步等问题 ##
- 消息队列、共享内存、信号量、socket
- ZeroMQ

## 五、Top K问题及HashMap、HashTable ##
1. 分治法：把整个大文件映射为1000个小文件，再找出每个小文件中出现频率最大的前K个IP（使用hashmap保存映射，在根据值排序），最后在1000个最大的IP中找出频率最大的IP。
2. 堆排序： 对于内存能放的下的情况，不使用分小文件，使用hash_map存储键值对。然后维护一个大小为K的小根堆，每次插入时与堆中第一个元素比较map['top']，与map['insert']如果比他大，则交换两个元素，然后shift_down。
3. **总结**：一是分治法，把大文件化为小文件，然后对小文件进行排序，最后归并。二是hash表，把空间变小，使用堆来维护K大小的堆。三是

## 六、排序算法、KMP算法 ##

